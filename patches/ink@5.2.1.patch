diff --git a/build/ink.js b/build/ink.js
index a9c444ff161ed4b6ea13909591844909015fe97c..5c44b4d87b66a110a81ecab4813f88845a0cfe04 100644
--- a/build/ink.js
+++ b/build/ink.js
@@ -56,9 +56,9 @@ export default class Ink {
         // so that it's rerendered every time, not just new static parts, like in non-debug mode
         this.fullStaticOutput = '';
         // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
-        this.container = reconciler.createContainer(this.rootNode, 
+        this.container = reconciler.createContainer(this.rootNode,
         // Legacy mode
-        0, null, false, null, 'id', () => { }, null);
+        0, null, false, null, 'id', () => { }, () => { }, () => { }, null);
         // Unmount when process exits
         this.unsubscribeExit = signalExit(this.unmount, { alwaysLast: false });
         if (process.env['DEV'] === 'true') {
diff --git a/build/reconciler.js b/build/reconciler.js
index 55acec78d35c8c1f0901720655e5ff1c58fd83c2..8de96d5707086be1f200482c98c4a0a4e6939aa1 100644
--- a/build/reconciler.js
+++ b/build/reconciler.js
@@ -58,6 +58,10 @@ const cleanupYogaNode = (node) => {
     node?.unsetMeasureFunc();
     node?.freeRecursive();
 };
+// Module-level flag: react-reconciler 0.31's commitUpdate receives the Fiber
+// (frozen) as the 5th arg instead of the root container. We bridge the static
+// dirty flag through resetAfterCommit, which does receive the root container.
+let _staticDirtyFlag = false;
 export default createReconciler({
     getRootHostContext: () => ({
         isInsideText: false,
@@ -66,6 +70,10 @@ export default createReconciler({
     preparePortalMount: () => null,
     clearContainer: () => false,
     resetAfterCommit(rootNode) {
+        if (_staticDirtyFlag) {
+            rootNode.isStaticDirty = true;
+            _staticDirtyFlag = false;
+        }
         if (typeof rootNode.onComputeLayout === 'function') {
             rootNode.onComputeLayout();
         }
@@ -162,31 +170,41 @@ export default createReconciler({
     scheduleTimeout: setTimeout,
     cancelTimeout: clearTimeout,
     noTimeout: -1,
-    getCurrentEventPriority: () => DefaultEventPriority,
+    resolveUpdatePriority: () => DefaultEventPriority,
+    getCurrentUpdatePriority: () => DefaultEventPriority,
+    setCurrentUpdatePriority() { },
     beforeActiveInstanceBlur() { },
     afterActiveInstanceBlur() { },
     detachDeletedInstance() { },
     getInstanceFromNode: () => null,
     prepareScopeUpdate() { },
     getInstanceFromScope: () => null,
+    shouldAttemptEagerTransition() { return false; },
+    maySuspendCommit() { return false; },
+    preloadInstance() { return true; },
+    startSuspendingCommit() { },
+    suspendInstance() { },
+    waitForCommitToBeReady() { return null; },
+    NotPendingTransition: null,
+    HostTransitionContext: { $$typeof: Symbol.for('react.context'), _currentValue: null, _currentValue2: null },
+    resetFormInstance() { },
+    supportsMicrotasks: true,
+    scheduleMicrotask: typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout,
     appendChildToContainer: appendChildNode,
     insertInContainerBefore: insertBeforeNode,
     removeChildFromContainer(node, removeNode) {
         removeChildNode(node, removeNode);
         cleanupYogaNode(removeNode.yogaNode);
     },
-    prepareUpdate(node, _type, oldProps, newProps, rootNode) {
+    commitUpdate(node, _type, oldProps, newProps, _fiber) {
         if (node.internal_static) {
-            rootNode.isStaticDirty = true;
+            _staticDirtyFlag = true;
         }
         const props = diff(oldProps, newProps);
         const style = diff(oldProps['style'], newProps['style']);
         if (!props && !style) {
-            return null;
+            return;
         }
-        return { props, style };
-    },
-    commitUpdate(node, { props, style }) {
         if (props) {
             for (const [key, value] of Object.entries(props)) {
                 if (key === 'style') {
